
const { createServer } = require('http');
const { Server } = require('socket.io');

const express = require('express');

//middlewares
const cors = require('cors');
const bodyParser = require('body-parser');

const { initializeMessageListener, sendMessageListener, disconnectListener } = require('./controllers/socketController');
const { authenticateUser, authMiddleware } = require('./controllers/authController'); 

const PORT = 5500;

const app = express();

const corsOption = {
        origin: ["http://localhost:5173", "http://localhost:5173"],
        methods: ["GET", "POST"]
    };

const server = createServer(app);


const io = new Server(server, {
    cors: corsOption
});


app.use(cors(corsOption));
app.use(bodyParser.json());

//this is used to catch up on the backlogs chat messages
//i.e, a user has logged in late



app.post('/auth/login', async (req, res) => {
    await authenticateUser(req, res);


} );

io.on("connection", (socket) => {

    console.log(`user: ${socket.id} has connected`);

    // if you're wondering why these next lines of code are nested, 
    // keep in mind that variables 'io' and 'socket' are different
    //'io' only has 1 instance that generates multiple sockets that are stored and named locally as 'socket'
    //everytime a 'socket' is generated by 'io', it initializes the following events

    //edit: I've refactored (idk if that's the term) the code and transferred it to ./controllers/socketConroller.js

    initializeMessageListener(io, socket);
    sendMessageListener(io, socket);
    disconnectListener(io, socket);

});

//whatym tryna say is, once any client sends a message, 
//the server broadcasts the message to all the other clients.
//and also interacts with itself through a callback function, letting the client know that the message was sent



server.listen(PORT, () => console.log(`Server listening on port: ${PORT}.`));
